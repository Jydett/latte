/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jorc;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.Scanner;
import java.util.ArrayList;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.VarInsnNode;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.MissingOptionException;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;

public class App {
    public static void main(String[] args) throws Exception {
        Options options = new Options();
        Option inputOption = new Option("i", "input", true, "input class file");

        options.addOption("h", "help", false, "");
        options.addOption("f", "force", false, "do not prompt before overwriting an existing output file");
        options.addOption("o", "output", true, "output class file");
        options.addOption(inputOption);

        HelpFormatter formatter = new HelpFormatter();

        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = parser.parse(options, args);

        if (cmd.hasOption("h")) {
            formatter.printHelp("myapp", "Rebuild the local variable tables in a class file", options, "", true);
            return;
        }
        if (!cmd.hasOption(inputOption)) {
            List<Option> missingOptions = new ArrayList<Option>(1);
            missingOptions.add(inputOption);
            throw new MissingOptionException(missingOptions);
        }
        String inputFileName = cmd.getOptionValue(inputOption);
        


        FileInputStream fi = new FileInputStream(inputFileName);
        ClassReader cr = new ClassReader(fi);

        ClassNode cn = new ClassNode();
        
        cr.accept(cn, 0);

        for (MethodNode methodNode : cn.methods) {
            if (methodNode.localVariables != null && methodNode.localVariables.size() > 0) {
                System.err.println(String.format("Method %s already contains local variables, skipping...", methodNode.name));
                //continue;
            }
            Type methodType = Type.getType(methodNode.desc);
            boolean isMethodStatic = (methodNode.access & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC;
            LabelNode last = null;
            if (!isMethodStatic || methodType.getArgumentTypes().length != 0) {
                LabelNode first = new LabelNode();
                last = new LabelNode();

                methodNode.instructions.insert(first);
                methodNode.instructions.add(last);

                int index = 0;
                if (!isMethodStatic) {
                    LocalVariableNode thisVar = new LocalVariableNode("this", Type.getObjectType(cn.name).toString(), null, first, last, index);
                    methodNode.localVariables.add(thisVar);
                    index++;
                }
                Type[] argTypes = methodType.getArgumentTypes();
                for (int i = 0; i < argTypes.length; i++) {
                    Type argType = argTypes[i];
                    LocalVariableNode argVar = new LocalVariableNode(String.format("arg%d", i+1), argType.getDescriptor(), null, first, last, index);
                    methodNode.localVariables.add(argVar);
                    index += argType.getSize();
                }
            }
            for (AbstractInsnNode insn : methodNode.instructions) {
                // check if this instruction stores a local var on the stack
                int opcode = insn.getOpcode();
                if (insn.getType() == AbstractInsnNode.VAR_INSN) {
                    Type varType;
                    if (opcode == Opcodes.ASTORE) {
                        AbstractInsnNode prev = insn.getPrevious();
                        if (prev.getType() == AbstractInsnNode.LDC_INSN) {
                            LdcInsnNode ldcInsnNode = ((LdcInsnNode)prev);
                            varType = Type.getType(ldcInsnNode.cst.getClass());
                        }
                        else if (prev.getType() == AbstractInsnNode.METHOD_INSN) {
                            MethodInsnNode methodInsnNode = ((MethodInsnNode)prev);
                            if (prev.getOpcode() == Opcodes.INVOKESPECIAL && methodInsnNode.name.equals("<init>")) {
                                do {
                                    prev = prev.getPrevious();
                                } while (prev.getOpcode() != Opcodes.NEW);
                                TypeInsnNode typeInsnNode = ((TypeInsnNode)prev);
                                varType = Type.getObjectType(typeInsnNode.desc);
                            }
                            else {
                                varType = Type.getType(methodInsnNode.desc).getReturnType();
                            }
                        }
                        else if (prev.getType() == AbstractInsnNode.INVOKE_DYNAMIC_INSN) {
                            InvokeDynamicInsnNode invokeDynamicInsnNode = ((InvokeDynamicInsnNode)prev);
                            varType = Type.getType(invokeDynamicInsnNode.desc).getReturnType();
                        }
                        else {
                            throw new Exception(String.format("Unexpected instruction type %d", prev.getType()));
                        }
                    }
                    else if (opcode == Opcodes.ISTORE) {
                        varType = Type.INT_TYPE;
                    }
                    else if(opcode == Opcodes.DSTORE) {
                        varType = Type.DOUBLE_TYPE;
                    }
                    else if(opcode == Opcodes.FSTORE) {
                        varType = Type.FLOAT_TYPE;
                    }
                    else if(opcode == Opcodes.LSTORE) {
                        varType = Type.LONG_TYPE;
                    }
                    else {
                        System.err.println(String.format("Opcode %d is not STORE instruction, skipping...", opcode));
                        continue;
                    }
                    
                    if (last == null) {
                        last = new LabelNode();
                        methodNode.instructions.add(last);
                    }
                    LabelNode varStart = new LabelNode();
                    methodNode.instructions.insert(insn, varStart);

                    VarInsnNode varIsnNode = ((VarInsnNode)insn);
                    LocalVariableNode localVar = new LocalVariableNode("local"+varIsnNode.var, varType.toString(), null, varStart, last, varIsnNode.var);
                    methodNode.localVariables.add(localVar);
                }
            }
        }
        // No need to recompute max or frames
        // because we aren't actually changing
        // the methods
        ClassWriter classWriter = new ClassWriter(0);
        cn.accept(classWriter);
 
        String outputFileName;
        if (!cmd.hasOption("o")) {
            outputFileName = inputFileName;
        }
        else {
            outputFileName = cmd.getOptionValue("o");
        }

        File outputFile = new File(outputFileName);
        if (outputFile.exists() && !cmd.hasOption("f")) {
            Scanner scanner = new Scanner(System.in);
            System.err.println(String.format("Overwrite the existing file %s?", outputFileName));
            if (!scanner.nextBoolean()) {
                return;
            }

        }

        OutputStream dout = new FileOutputStream(outputFile);
        dout.write(classWriter.toByteArray());
        dout.flush();
        dout.close();
    }
}
